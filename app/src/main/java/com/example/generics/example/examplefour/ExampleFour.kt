package com.example.generics.example.examplefour

fun index() {
    Basic()
    Adavanced()
}


fun Basic() {

    // class Cup<T> // go com.example.generics.example.examplefour/Cup
    // Type parameter T in above declaration does not have any variance modifier (out or in) and by default it is invariant. It means that there is no relation between any two types generated by this generic class. For instance, there is no relation between Cup<Int> and Cup<Number>, Cup<Any> or Cup<Nothing>.


    //TODO uncomment code
    /*val anys: Cup<Any> = Cup<Int>() // Error: Type mismatch
    val nothings: Cup<Nothing> = Cup<Int>()*/ // Error: Type mismatch

    // If we need such relation, then we should use variance modifiers: out or in. out makes type parameter covariant. It means that when Tea/Coffee is subtype of Milk and ProducerCup is covariant, then type ProducerCup<Tea> is subtype of ProducerCup<Milk>:

    val milkCoffee: ProducerCup<Milk> = ProducerCup<Coffee>() // OK
    //TODO uncomment code
    /*val coffee: ProducerCup<Coffee> = ProducerCup<Milk>*/ // Error: Type mismatch

    val milkTea: ProducerCup<Milk> = ProducerCup<Tea>() // OK
    //TODO uncomment code
    /*val tea: ProducerCup<Tea> = ProducerCup<Milk>*/ // Error: Type mismatch

    val _anys: ProducerCup<Any> = ProducerCup<Int>() // OK
    //TODO uncomment code
    /*val _nothings: ProducerCup<Nothing> = ProducerCup<Int>()*/ // Error: Type mismatch

    // The opposite effect can be achieved using in modifier, which makes type parameter contravariant. It means that when Tea/Coffee is subtype of Milk and Cup is contravariant, then type ConsumerCup<Tea> is supertype of ConsumerCup<Milk>:

    val _milkCofee: ConsumerCup<Coffee> = ConsumerCup<Milk>()// OK
    //TODO uncomment code
    /*val _coffee: ConsumerCup<Milk> = ConsumerCup<Coffee>()*/ // Error: Type mismatch

    val _milkTea: ConsumerCup<Tea> = ConsumerCup<Milk>()// OK
    //TODO uncomment code
    /*val _tea: ConsumerCup<Milk> = ConsumerCup<Tea>()*/ // Error: Type mismatch
}

fun Adavanced() {
    // Problem with covariance
    // As you can see, problem with covariance is with mutability after upcasting. If you analyze it more deeply, covariant type parameter — not only on setter, but on any in position (public methods parameters or public property) — is potential source of errors. This is why Kotlin, which is guarding type safeness, prohibits covariant type parameters use on in positions:

    //TODO uncomment code
    /*class ProducerCup<out T>(
        var elem: T // Error: T not allowed on invariant position
    ) {
        fun set(new: T) { // Error: T not allowed on in position
            elem = new
        }

        fun get(): T = elem
    }*/

    // We can correct above code by using type argument only on out positions (public methods return types) and not on in positions (public methods arguments) or invariant positions (public properties):

    class CorrectedProducerCup<out T>(
        private var elem: T
    ) {
        fun get(): T = elem
    }


    // Problem with contravariance
    //TODO uncomment code
    /* class ConsumerCup<in T>(
         var elem: T // Error: T not allowed on invariant position
     ) {
         fun set(new: T) {
             elem = new
         }

         fun get(): T = elem // Error: T not allowed on out position
     }*/

    // We can correct it by using type argument only on in positions (public methods arguments) and not on out positions (public methods return types) or invariant positions (public properties):

    class CorrectedConsumerCup<in T>(
        private var elem: T
    ) {
        fun set(new: T) {
            elem = new
        }
    }


    //Note that invariant type argument is allowed in all positions:
    class Cup<T>(
        var elem: T
    ) {
        fun set(new: T) {
            elem = new
        }

        fun get(): T = elem
    }
}